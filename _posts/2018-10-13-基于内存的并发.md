---
title: java并发分享(一) —— 基于内存的并发
key: 20181013
tags: java 并发
---

# 基于共享内存的并发编程

在基于共享内存的并发编程中，线程间通过读写共享的变量进行隐式的通信。在多线程并发读写共享变量的场景下，如果没有进行正确的同步，将会导致一些非预期的结果。

在编写正确的并发代码中，我们主要需要关注以下3个点

* 原子性：什么操作在什么条件下是原子的

* 可见性：一个线程对一个共享变量的写操作，写入的值在什么条件下，其它线程能够读到

* 有序性：在同一个线程内，代码的执行顺序看起来与编写的代码顺序一致。在正确同步下，一个线程(通过共享变量)观察另一个线程代码的执行顺序，看起来与编写的代码顺序一致

我们先看下面的case

```java
    private static int a = 0;   
    private static int b = 0;

    // 线程A执行
    public static void threadRunA(){
        a = 1;
        b = 1;
    }
    // 线程B执行
    public static void threadRunB(){
        while (b != 1){}
        assert(a == 1);
    }

```

线程AB并发执行，线程B中的断言是否一定成功？

由于上述方法threadRunA，threadRunB运行在不同的线程中，且对于共享变量a,b的读写没有进行同步，因此在线程B通过共享变量a,b中观察线程A的赋值逻辑的顺序不一定是a先赋值，b再赋值。所以断言不一定成功

对于操作的原子性，大家其实都比较了解，比如 i++这样的代码就不是原子的。

但是基于我们平常的认知：

* 一个变量如果被写入，那么在此之后对该变量的访问，应该都能读取到最新写入的值。
* 一段代码的编写顺序与最终执行的顺序应该相同。

如上认知被称为顺序一致性。
实际上，顺序一致性在单线程下总是是成立的（如果不成立的话连程序运行正确都无法保证），但在多线程的情况下，只有在正确同步的情况下才能成立

why？如果我们进行并发编程的时候没有正确的同步，是什么影响到程序的顺序一致性？

主要原因在于编译器与处理器对于程序执行的优化，影响顺序一致性的优化：
* CPU高速缓存
* CPU指令重排序
* 编译器重排序
